/*
 * test_do_while.c
 *
 * Tests for the do-while loop in the Viola scripting language.
 * Syntax:  do (init_expr) stmt while (condition_expr);
 *
 * The grammar (gram.y:342) parses do-while and builds AST_DO nodes,
 * but codeGen() had no handler for AST_DO — it fell through to the
 * default error case. These tests verify parsing and execution.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../src/viola/ast.h"
#include "../src/viola/cgen.h"

/* Stubs for symbols not needed by the test */
int verbose = 0;

/* External declarations for the interpreter pipeline */
extern AST *theAST;
extern int lineno;
extern char *yyscript;
extern int yyscriptidx;
extern char *yyobjcontext;
extern int yyscriptcontext;
extern int varArrayIdx;
extern int listRefArrayIdx;

extern int yyparse(void);
extern void set_parsing_string(char *s);
extern int init_scanutils(void);
extern int init_ast(void);
extern int init_ident(void);

/* ========================================================================
 * Part 1: Parser tests
 * ======================================================================== */

static int try_parse(char *script)
{
    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    return (yyparse() == 0 && theAST != NULL);
}

static AST *find_ast_type(AST *ast, int type)
{
    AST *found;
    for (; ast; ast = ast->next) {
        if (ast->type == type)
            return ast;
        if (ast->children) {
            found = find_ast_type(ast->children, type);
            if (found)
                return found;
        }
    }
    return NULL;
}

static int test_parse_basic(void)
{
    /* do (i = 0) { i = i + 1; } while (i < 3); */
    if (!try_parse("do (i = 0) { i = i + 1; } while (i < 3);"))
        return 0;
    return find_ast_type(theAST, AST_DO) != NULL;
}

static int test_parse_false_cond(void)
{
    /* do-while with always-false condition — body should still run once */
    if (!try_parse("do (x = 0) { x = x + 1; } while (0);"))
        return 0;
    return find_ast_type(theAST, AST_DO) != NULL;
}

static int test_parse_structure(void)
{
    /* Verify AST structure: AST_DO → children: init → body → condition */
    if (!try_parse("do (i = 0) { i = i + 1; } while (i < 5);"))
        return 0;
    AST *doNode = find_ast_type(theAST, AST_DO);
    if (!doNode || !doNode->children)
        return 0;
    /* children = init expr (MOVTO_REF for i=0) */
    AST *init = doNode->children;
    /* init->next = body (AST_BODY) */
    if (!init->next || init->next->type != AST_BODY)
        return 0;
    /* body->next = condition expr */
    if (!init->next->next)
        return 0;
    return 1;
}

static int test_parse_single_stmt(void)
{
    /* do-while with a single statement (no braces) */
    if (!try_parse("do (i = 0) i = i + 1; while (i < 3);"))
        return 0;
    return find_ast_type(theAST, AST_DO) != NULL;
}

static int test_parse_nested(void)
{
    /* do-while inside an if */
    if (!try_parse("if (1) { do (i = 0) { i = i + 1; } while (i < 2); }"))
        return 0;
    if (!find_ast_type(theAST, AST_IF))
        return 0;
    return find_ast_type(theAST, AST_DO) != NULL;
}

/* ========================================================================
 * Part 2: Codegen + execution tests
 *
 * Uses a mini pcode executor with variable support.
 * ======================================================================== */

static union PCode test_pcode[5000];

static int compile_script(char *script)
{
    int pc_limit = 0;
    AST *ast;

    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    if (yyparse() != 0 || theAST == NULL)
        return -1;

    if (!assignReferences(theAST, test_pcode, &pc_limit))
        return -1;

    for (ast = theAST; ast; ast = ast->next)
        codeGen(ast, test_pcode, &pc_limit);

    return pc_limit;
}

/*
 * Mini pcode executor with variable support.
 *
 * Handles the subset of opcodes generated by simple loops:
 * integers, variable read/write, basic arithmetic/comparison,
 * branches, NOT, etc. Returns vars[0] (the first variable).
 */
#define MINI_MAX_VARS 32
#define MINI_MAX_ITER 100000  /* safety: prevent infinite loops */

static long mini_exec_var(union PCode *pcode, int size)
{
    int pc = 0;
    long reg = 0;
    int reg_is_str = 0;
    char *reg_s = NULL;
    long vars[MINI_MAX_VARS];
    int iter = 0;

    memset(vars, 0, sizeof(vars));

    while (pc < size && iter++ < MINI_MAX_ITER) {
        long code = pcode[pc++].x;

        if (code & 0xe0000000) {
            int opcode = (int)((code >> 16) & 0x0fff);
            int data = (int)(code & 0x0000ffff);

            switch (opcode) {
            case CODE_INTEGER:
                reg = data;
                reg_is_str = 0;
                break;
            case CODE_CHAR:
                reg = data;
                reg_is_str = 0;
                break;
            case CODE_REF2:
                reg = (data < MINI_MAX_VARS) ? vars[data] : 0;
                reg_is_str = 0;
                break;
            case CODE_MOVTO_REF2:
                if (data < MINI_MAX_VARS) vars[data] = reg;
                break;
            case CODE_BR2:
                pc += data;
                break;
            case CODE_BR2_ZERO:
                if (reg == 0 && !reg_is_str) pc += data;
                break;
            case CODE_BR2_NZERO:
                if (reg != 0) pc += data;
                break;
            case CODE_NBR2:
                pc -= data;
                break;
            case CODE_NBR2_NZERO:
                if (reg != 0) pc -= data;
                break;
            case CODE_NBR2_ZERO:
                if (reg == 0) pc -= data;
                break;
            case CODE_LIST2:
            case CODE_LIST_REF2:
            case CODE_LISTC2:
            case CODE_GET2:
            case CODE_PUSH_SET2:
                break;
            case CODE_CALL2:
            case CODE_CALL2_C:
                pc++; /* skip function id */
                break;
            default:
                break;
            }
        } else {
            switch ((int)code) {
            /* Variable ops */
            case CODE_PUSH_REFPS: {
                int n = (int)pcode[pc++].i;
                pc += n;
                break;
            }

            /* Arithmetic with immediate int */
            case CODE_PLUS_INT:
                reg += pcode[pc++].i;
                break;
            case CODE_MINUS_INT:
                reg -= pcode[pc++].i;
                break;
            case CODE_MULT_INT:
                reg *= pcode[pc++].i;
                break;
            case CODE_DIV_INT: {
                long d = pcode[pc++].i;
                if (d) reg /= d;
                break;
            }
            case CODE_MOD_INT: {
                long d = pcode[pc++].i;
                if (d) reg %= d;
                break;
            }

            /* Comparison with immediate int */
            case CODE_EQ_INT:
                reg = (reg == pcode[pc++].i);
                break;
            case CODE_NE_INT:
                reg = (reg != pcode[pc++].i);
                break;
            case CODE_LT_INT:
                reg = (reg < pcode[pc++].i);
                break;
            case CODE_LE_INT:
                reg = (reg <= pcode[pc++].i);
                break;
            case CODE_GT_INT:
                reg = (reg > pcode[pc++].i);
                break;
            case CODE_GE_INT:
                reg = (reg >= pcode[pc++].i);
                break;

            /* Arithmetic/comparison with immediate ref (variable) */
            case CODE_PLUS_REF: {
                int idx = (int)pcode[pc++].i;
                reg += (idx < MINI_MAX_VARS) ? vars[idx] : 0;
                break;
            }
            case CODE_MINUS_REF: {
                int idx = (int)pcode[pc++].i;
                reg -= (idx < MINI_MAX_VARS) ? vars[idx] : 0;
                break;
            }
            case CODE_LT_REF: {
                int idx = (int)pcode[pc++].i;
                reg = reg < ((idx < MINI_MAX_VARS) ? vars[idx] : 0);
                break;
            }
            case CODE_GT_REF: {
                int idx = (int)pcode[pc++].i;
                reg = reg > ((idx < MINI_MAX_VARS) ? vars[idx] : 0);
                break;
            }
            case CODE_EQ_REF: {
                int idx = (int)pcode[pc++].i;
                reg = (reg == ((idx < MINI_MAX_VARS) ? vars[idx] : 0));
                break;
            }
            case CODE_NE_REF: {
                int idx = (int)pcode[pc++].i;
                reg = (reg != ((idx < MINI_MAX_VARS) ? vars[idx] : 0));
                break;
            }
            case CODE_LE_REF: case CODE_GE_REF:
            case CODE_MULT_REF: case CODE_DIV_REF: case CODE_MOD_REF:
            case CODE_AND_REF: case CODE_OR_REF:
                pc++; /* consume operand */
                break;

            /* Increment/decrement */
            case CODE_INC_PRE: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = ++vars[idx];
                break;
            }
            case CODE_INC_POST: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = vars[idx]++;
                break;
            }
            case CODE_DEC_PRE: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = --vars[idx];
                break;
            }
            case CODE_DEC_POST: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = vars[idx]--;
                break;
            }

            /* Unary */
            case CODE_NOT:
                if (reg_is_str)
                    reg = (!reg_s || !*reg_s) ? 1 : 0;
                else
                    reg = !reg;
                reg_is_str = 0;
                break;
            case CODE_UMINUS:
                reg = -reg;
                reg_is_str = 0;
                break;

            /* Literals */
            case CODE_INTEGER:
                reg = pcode[pc++].i;
                reg_is_str = 0;
                break;
            case CODE_FLOAT:
                pc++;
                break;
            case CODE_STRING:
                reg_s = pcode[pc++].s;
                reg_is_str = 1;
                break;
            case CODE_CHAR:
                reg = (long)pcode[pc++].c;
                reg_is_str = 0;
                break;

            /* Assignment ops (consume operand) */
            case CODE_MOVTO_LIST:
            case CODE_PLUS_MOVTO_REF:  case CODE_MINUS_MOVTO_REF:
            case CODE_MOD_MOVTO_REF:   case CODE_MULT_MOVTO_REF:
            case CODE_DIV_MOVTO_REF:
            case CODE_PLUS_MOVTO_LIST: case CODE_MINUS_MOVTO_LIST:
            case CODE_MOD_MOVTO_LIST:  case CODE_MULT_MOVTO_LIST:
            case CODE_DIV_MOVTO_LIST:
                pc++;
                break;

            /* Immediate string/char/float binary ops */
            case CODE_PLUS_STR: case CODE_MINUS_STR: case CODE_MULT_STR:
            case CODE_DIV_STR:  case CODE_MOD_STR:   case CODE_EQ_STR:
            case CODE_NE_STR:   case CODE_LT_STR:    case CODE_LE_STR:
            case CODE_GT_STR:   case CODE_GE_STR:    case CODE_AND_STR:
            case CODE_OR_STR:
            case CODE_PLUS_CHAR: case CODE_MINUS_CHAR: case CODE_MULT_CHAR:
            case CODE_DIV_CHAR:  case CODE_MOD_CHAR:   case CODE_EQ_CHAR:
            case CODE_NE_CHAR:   case CODE_LT_CHAR:    case CODE_LE_CHAR:
            case CODE_GT_CHAR:   case CODE_GE_CHAR:    case CODE_AND_CHAR:
            case CODE_OR_CHAR:
            case CODE_PLUS_FLOAT: case CODE_MINUS_FLOAT: case CODE_MULT_FLOAT:
            case CODE_DIV_FLOAT:  case CODE_MOD_FLOAT:   case CODE_EQ_FLOAT:
            case CODE_NE_FLOAT:   case CODE_LT_FLOAT:    case CODE_LE_FLOAT:
            case CODE_GT_FLOAT:   case CODE_GE_FLOAT:    case CODE_AND_FLOAT:
            case CODE_OR_FLOAT:
                pc++;
                break;

            /* Logic with immediate int */
            case CODE_AND_INT:
                reg = reg && pcode[pc++].i;
                break;
            case CODE_OR_INT:
                reg = reg || pcode[pc++].i;
                break;

            /* Stack-based binary ops (no extra data) */
            case CODE_EQ_STACK:
            case CODE_PLUS_POP: case CODE_MINUS_POP: case CODE_MULT_POP:
            case CODE_DIV_POP:  case CODE_MOD_POP:   case CODE_EQ_POP:
            case CODE_NE_POP:   case CODE_LT_POP:    case CODE_LE_POP:
            case CODE_GT_POP:   case CODE_GE_POP:    case CODE_AND_POP:
            case CODE_OR_POP:
                break;

            /* Misc no-data opcodes */
            case CODE_PUSH:
            case CODE_POP:
            case CODE_CMP:
            case CODE_LOAD:
            case CODE_STMTS:
            case CODE_TOKENIZE_PUSH:
            case CODE_METH_SELF:
            case CODE_METH_PARENT:
                break;
            case CODE_METH_SEND:
                pc++;
                break;
            case CODE_RETURN:
                goto done;
            default:
                break;
            }
        }
    }
done:
    return vars[0]; /* return the first variable's value */
}

/*
 * eval_var: compile and execute, return vars[0].
 */
static int eval_var(char *script, long *out)
{
    int size = compile_script(script);
    if (size <= 0) {
        fprintf(stderr, "    compile failed (size=%d)\n", size);
        return 0;
    }
    *out = mini_exec_var(test_pcode, size);
    return 1;
}

/* --- Execution tests --- */

static int test_exec_basic_loop(void)
{
    /* do (i = 0) { i = i + 1; } while (i < 3); → i = 3 */
    long r;
    return eval_var("do (i = 0) { i = i + 1; } while (i < 3);", &r) && r == 3;
}

static int test_exec_body_runs_once(void)
{
    /* Body must execute at least once even when condition is immediately false */
    /* do (x = 0) { x = x + 1; } while (0); → x = 1 */
    long r;
    return eval_var("do (x = 0) { x = x + 1; } while (0);", &r) && r == 1;
}

static int test_exec_count_to_five(void)
{
    long r;
    return eval_var("do (i = 0) { i = i + 1; } while (i < 5);", &r) && r == 5;
}

static int test_exec_countdown(void)
{
    /* Count down from 10 to 0 */
    long r;
    return eval_var("do (i = 10) { i = i - 1; } while (i > 0);", &r) && r == 0;
}

static int test_exec_init_value(void)
{
    /* Init sets starting value, body increments once, condition is false → runs once */
    /* do (i = 42) { i = i + 1; } while (0); → i = 43 */
    long r;
    return eval_var("do (i = 42) { i = i + 1; } while (0);", &r) && r == 43;
}

static int test_exec_single_iteration(void)
{
    /* Condition is true only for one iteration */
    /* do (i = 0) { i = i + 1; } while (i < 1); → i = 1 */
    long r;
    return eval_var("do (i = 0) { i = i + 1; } while (i < 1);", &r) && r == 1;
}

static int test_exec_with_increment(void)
{
    /* Use i++ instead of i = i + 1 */
    long r;
    return eval_var("do (i = 0) { i++; } while (i < 4);", &r) && r == 4;
}

/* ========================================================================
 * Test runner
 * ======================================================================== */

int main(void)
{
    int passed = 0, total = 0;

    printf("Do-While Loop Tests\n");
    printf("====================\n");

    if (!init_ident()) { fprintf(stderr, "init_ident failed\n"); return 1; }
    if (!init_scanutils()) { fprintf(stderr, "init_scanutils failed\n"); return 1; }
    if (!init_ast()) { fprintf(stderr, "init_ast failed\n"); return 1; }

#define RUN(name, func) do { \
    total++; \
    if (func()) { passed++; printf("  ok  %s\n", name); } \
    else { printf("  FAIL  %s\n", name); } \
} while (0)

    printf("\n--- Parser ---\n");
    RUN("parse basic do-while",     test_parse_basic);
    RUN("parse false condition",    test_parse_false_cond);
    RUN("parse AST structure",      test_parse_structure);
    RUN("parse single statement",   test_parse_single_stmt);
    RUN("parse nested in if",       test_parse_nested);

    printf("\n--- Execution ---\n");
    RUN("exec loop to 3",          test_exec_basic_loop);
    RUN("exec body runs once",     test_exec_body_runs_once);
    RUN("exec count to 5",         test_exec_count_to_five);
    RUN("exec countdown 10→0",     test_exec_countdown);
    RUN("exec init value 42",      test_exec_init_value);
    RUN("exec single iteration",   test_exec_single_iteration);
    RUN("exec with i++",           test_exec_with_increment);

#undef RUN

    printf("\nResults: %d/%d passed\n", passed, total);
    return (passed == total) ? 0 : 1;
}
