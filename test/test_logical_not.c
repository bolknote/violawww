/*
 * test_logical_not.c
 *
 * Tests for the ! (logical NOT) operator in the Viola scripting language.
 * The ! operator was declared in the grammar's precedence table (gram.y:66)
 * but had no production rule, making it unparseable. These tests verify:
 *   1. Parsing: the operator is accepted and produces the correct AST.
 *   2. Execution: scripts compile to pcode containing CODE_NOT, and a
 *      mini-executor verifies the correct runtime behavior.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../src/viola/ast.h"
#include "../src/viola/cgen.h"

/* Stubs for symbols not needed by the test */
int verbose = 0;

/* External declarations for the interpreter pipeline */
extern AST *theAST;
extern int lineno;
extern char *yyscript;
extern int yyscriptidx;
extern char *yyobjcontext;
extern int yyscriptcontext;
extern int varArrayIdx;
extern int listRefArrayIdx;

extern int yyparse(void);
extern void set_parsing_string(char *s);
extern int init_scanutils(void);
extern int init_ast(void);
extern int init_ident(void);

/* ========================================================================
 * Part 1: Parser tests (AST level)
 * ======================================================================== */

static int try_parse(char *script)
{
    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    return (yyparse() == 0 && theAST != NULL);
}

static AST *find_ast_type(AST *ast, int type)
{
    AST *found;
    for (; ast; ast = ast->next) {
        if (ast->type == type)
            return ast;
        if (ast->children) {
            found = find_ast_type(ast->children, type);
            if (found)
                return found;
        }
    }
    return NULL;
}

static int test_parse_not_integer(void)
{
    if (!try_parse("x = !0;")) return 0;
    return find_ast_type(theAST, AST_EXPR_NOT) != NULL;
}

static int test_parse_not_variable(void)
{
    if (!try_parse("x = !y;")) return 0;
    return find_ast_type(theAST, AST_EXPR_NOT) != NULL;
}

static int test_parse_not_in_if(void)
{
    if (!try_parse("if (!x) { y = 1; }")) return 0;
    return find_ast_type(theAST, AST_EXPR_NOT) != NULL;
}

static int test_parse_double_not(void)
{
    if (!try_parse("x = !!y;")) return 0;
    AST *first = find_ast_type(theAST, AST_EXPR_NOT);
    if (!first) return 0;
    return find_ast_type(first->children, AST_EXPR_NOT) != NULL;
}

static int test_parse_not_of_comparison(void)
{
    if (!try_parse("z = !(x == y);")) return 0;
    AST *n = find_ast_type(theAST, AST_EXPR_NOT);
    if (!n) return 0;
    return find_ast_type(n->children, AST_EXPR_EQ) != NULL;
}

static int test_parse_not_func_call(void)
{
    if (!try_parse("x = !func();")) return 0;
    AST *n = find_ast_type(theAST, AST_EXPR_NOT);
    if (!n) return 0;
    return find_ast_type(n->children, AST_CALL) != NULL;
}

static int test_parse_not_in_while(void)
{
    if (!try_parse("while (!done) { i++; }")) return 0;
    AST *w = find_ast_type(theAST, AST_WHILE);
    if (!w) return 0;
    return find_ast_type(w->children, AST_EXPR_NOT) != NULL;
}

static int test_parse_not_with_and(void)
{
    if (!try_parse("x = !a && !b;")) return 0;
    return find_ast_type(theAST, AST_EXPR_AND) != NULL;
}

static int test_parse_not_string(void)
{
    if (!try_parse("x = !\"\";")) return 0;
    return find_ast_type(theAST, AST_EXPR_NOT) != NULL;
}

/* ========================================================================
 * Part 2: Codegen + execution tests (direct interpreter call, no browser)
 *
 * Pipeline: source → yyparse → assignReferences → codeGen → mini_exec
 *
 * mini_exec is a tiny pcode interpreter that handles only the opcodes
 * generated by simple expressions (INTEGER, STRING, NOT, UMINUS, etc.).
 * This avoids depending on the full codeExec (which needs VObj, X11, ...).
 * ======================================================================== */

static union PCode test_pcode[5000];

/*
 * compile_script: parse + codegen, produces pcode in test_pcode[].
 * Returns the pcode instruction count, or -1 on error.
 */
static int compile_script(char *script)
{
    int pc_limit = 0;
    AST *ast;

    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    if (yyparse() != 0 || theAST == NULL)
        return -1;

    if (!assignReferences(theAST, test_pcode, &pc_limit))
        return -1;

    for (ast = theAST; ast; ast = ast->next)
        codeGen(ast, test_pcode, &pc_limit);

    return pc_limit;
}

/*
 * mini_exec: a minimal pcode interpreter for testing.
 * Handles only the opcodes produced by simple expressions.
 * Returns the final value of reg1 as a long integer.
 */
static long mini_exec(union PCode *pcode, int size)
{
    int pc = 0;
    long reg_i = 0;        /* integer register */
    int reg_is_str = 0;    /* 1 if register holds a string */
    char *reg_s = NULL;    /* string register */

    while (pc < size) {
        long code = pcode[pc++].x;

        if (code & 0xe0000000) {
            /* Combined instruction: opcode in bits 16..27, data in bits 0..15 */
            int opcode = (int)((code >> 16) & 0x0fff);
            int data = (int)(code & 0x0000ffff);

            switch (opcode) {
            case CODE_INTEGER:
                reg_i = data;
                reg_is_str = 0;
                break;
            case CODE_CHAR:
                reg_i = data;
                reg_is_str = 0;
                break;
            case CODE_MOVTO_REF2:  /* assignment — just consume */
            case CODE_REF2:        /* variable read */
            case CODE_LIST_REF2:
            case CODE_LISTC2:
            case CODE_LIST2:
            case CODE_GET2:
            case CODE_PUSH_SET2:
                break;
            case CODE_BR2:
                pc += data;
                break;
            case CODE_BR2_ZERO:
                if (reg_i == 0 && !reg_is_str) pc += data;
                break;
            case CODE_NBR2:
                pc -= data;
                break;
            case CODE_CALL2:
            case CODE_CALL2_C:
                pc++; /* skip function id */
                break;
            default:
                break;
            }
        } else {
            /* Regular (single-word opcode) instruction */
            switch ((int)code) {
            case CODE_NOT:
                if (reg_is_str)
                    reg_i = (!reg_s || !*reg_s) ? 1 : 0;
                else
                    reg_i = !reg_i;
                reg_is_str = 0;
                break;
            case CODE_UMINUS:
                reg_i = -reg_i;
                reg_is_str = 0;
                break;
            case CODE_INTEGER:
                reg_i = pcode[pc++].i;
                reg_is_str = 0;
                break;
            case CODE_FLOAT:
                pc++; /* skip float value */
                reg_is_str = 0;
                break;
            case CODE_STRING:
                reg_s = pcode[pc++].s;
                reg_is_str = 1;
                break;
            case CODE_CHAR:
                reg_i = (long)pcode[pc++].c;
                reg_is_str = 0;
                break;
            case CODE_PUSH_REFPS: {
                int n = (int)pcode[pc++].i;
                pc += n; /* skip symbol IDs */
                break;
            }
            case CODE_PUSH:
            case CODE_POP:
            case CODE_RETURN:
            case CODE_TOKENIZE_PUSH:
                break;

            /* Binary ops with immediate int — consume the operand word */
            case CODE_PLUS_INT: case CODE_MINUS_INT: case CODE_MULT_INT:
            case CODE_DIV_INT:  case CODE_MOD_INT:   case CODE_EQ_INT:
            case CODE_NE_INT:   case CODE_LT_INT:    case CODE_LE_INT:
            case CODE_GT_INT:   case CODE_GE_INT:    case CODE_AND_INT:
            case CODE_OR_INT:
            case CODE_PLUS_REF: case CODE_MINUS_REF: case CODE_MULT_REF:
            case CODE_DIV_REF:  case CODE_MOD_REF:   case CODE_EQ_REF:
            case CODE_NE_REF:   case CODE_LT_REF:    case CODE_LE_REF:
            case CODE_GT_REF:   case CODE_GE_REF:    case CODE_AND_REF:
            case CODE_OR_REF:
            case CODE_INC_PRE:  case CODE_INC_POST:
            case CODE_DEC_PRE:  case CODE_DEC_POST:
            case CODE_MOVTO_LIST:
            case CODE_PLUS_MOVTO_REF:  case CODE_MINUS_MOVTO_REF:
            case CODE_MOD_MOVTO_REF:   case CODE_MULT_MOVTO_REF:
            case CODE_DIV_MOVTO_REF:
            case CODE_PLUS_MOVTO_LIST: case CODE_MINUS_MOVTO_LIST:
            case CODE_MOD_MOVTO_LIST:  case CODE_MULT_MOVTO_LIST:
            case CODE_DIV_MOVTO_LIST:
                pc++; /* skip operand */
                break;

            /* Binary ops with immediate string — consume the operand word */
            case CODE_PLUS_STR: case CODE_MINUS_STR: case CODE_MULT_STR:
            case CODE_DIV_STR:  case CODE_MOD_STR:   case CODE_EQ_STR:
            case CODE_NE_STR:   case CODE_LT_STR:    case CODE_LE_STR:
            case CODE_GT_STR:   case CODE_GE_STR:    case CODE_AND_STR:
            case CODE_OR_STR:
                pc++;
                break;

            /* Opcodes with no additional data */
            case CODE_EQ_STACK:
            case CODE_PLUS_POP: case CODE_MINUS_POP: case CODE_MULT_POP:
            case CODE_DIV_POP:  case CODE_MOD_POP:   case CODE_EQ_POP:
            case CODE_NE_POP:   case CODE_LT_POP:    case CODE_LE_POP:
            case CODE_GT_POP:   case CODE_GE_POP:    case CODE_AND_POP:
            case CODE_OR_POP:
            case CODE_CMP: case CODE_LOAD: case CODE_STMTS:
            case CODE_METH_SELF: case CODE_METH_PARENT:
                break;

            case CODE_METH_SEND:
                pc++; /* skip argc */
                break;

            default:
                break;
            }
        }
    }
    return reg_i;
}

/*
 * eval: compile a script and execute it, return the integer result.
 */
static int eval(char *script, long *out)
{
    int size = compile_script(script);
    if (size < 0) return 0;
    *out = mini_exec(test_pcode, size);
    return 1;
}

/* --- Execution tests --- */

static int test_exec_not_zero(void)
{
    long r;
    return eval("!0;", &r) && r == 1;
}

static int test_exec_not_one(void)
{
    long r;
    return eval("!1;", &r) && r == 0;
}

static int test_exec_not_positive(void)
{
    long r;
    return eval("!42;", &r) && r == 0;
}

static int test_exec_not_negative(void)
{
    long r;
    return eval("!-1;", &r) && r == 0;
}

static int test_exec_double_not_zero(void)
{
    long r;
    return eval("!!0;", &r) && r == 0;
}

static int test_exec_double_not_one(void)
{
    long r;
    return eval("!!1;", &r) && r == 1;
}

static int test_exec_triple_not(void)
{
    long r;
    return eval("!!!0;", &r) && r == 1;
}

static int test_exec_not_empty_string(void)
{
    long r;
    return eval("!\"\";", &r) && r == 1;
}

static int test_exec_not_nonempty_string(void)
{
    long r;
    return eval("!\"hello\";", &r) && r == 0;
}

static int test_exec_not_char(void)
{
    long r;
    /* !'a' should be 0 (non-zero char → false) */
    return eval("!'a';", &r) && r == 0;
}

static int test_exec_not_null_char(void)
{
    long r;
    /* !'\0' — null char should be truthy for NOT (zero value → true) */
    /* '\0' has ascii value 0, so !0 = 1 */
    return eval("!'\\000';", &r) && r == 1;
}

/* ========================================================================
 * Test runner
 * ======================================================================== */

int main(void)
{
    int passed = 0, total = 0;

    printf("Logical NOT Operator Tests\n");
    printf("==========================\n");

    if (!init_ident()) { fprintf(stderr, "init_ident failed\n"); return 1; }
    if (!init_scanutils()) { fprintf(stderr, "init_scanutils failed\n"); return 1; }
    if (!init_ast()) { fprintf(stderr, "init_ast failed\n"); return 1; }

#define RUN(name, func) do { \
    total++; \
    if (func()) { passed++; printf("  ok  %s\n", name); } \
    else { printf("  FAIL  %s\n", name); } \
} while (0)

    printf("\n--- Parser ---\n");
    RUN("parse !integer",       test_parse_not_integer);
    RUN("parse !variable",      test_parse_not_variable);
    RUN("parse if (!x)",        test_parse_not_in_if);
    RUN("parse !!y",            test_parse_double_not);
    RUN("parse !(x == y)",      test_parse_not_of_comparison);
    RUN("parse !func()",        test_parse_not_func_call);
    RUN("parse while (!done)",  test_parse_not_in_while);
    RUN("parse !a && !b",       test_parse_not_with_and);
    RUN("parse !\"\"",          test_parse_not_string);

    printf("\n--- Execution ---\n");
    RUN("exec !0 = 1",          test_exec_not_zero);
    RUN("exec !1 = 0",          test_exec_not_one);
    RUN("exec !42 = 0",         test_exec_not_positive);
    RUN("exec !-1 = 0",         test_exec_not_negative);
    RUN("exec !!0 = 0",         test_exec_double_not_zero);
    RUN("exec !!1 = 1",         test_exec_double_not_one);
    RUN("exec !!!0 = 1",        test_exec_triple_not);
    RUN("exec !\"\" = 1",       test_exec_not_empty_string);
    RUN("exec !\"hello\" = 0",  test_exec_not_nonempty_string);
    RUN("exec !'a' = 0",        test_exec_not_char);
    RUN("exec !'\\0' = 1",      test_exec_not_null_char);

#undef RUN

    printf("\nResults: %d/%d passed\n", passed, total);
    return (passed == total) ? 0 : 1;
}
