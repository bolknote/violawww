
	switch (arg[0]) {
	case "shownPositionV":
		return send(pageObj, "shownPositionV", arg[1]);
	break;
	case "initKludge":
		return;
	break;
	case "show":
	case "post":
		if (configed == 0) {
			after(1000, self(), arg[0], arg[1]);
			return -1;
		}

		if (arg[0] == "post") {
			doPost = 1;
			postData = arg[3];
		} else { 
			doPost = 0;
			postData = 0;
		}
		if (torn == 1) {
			if (arg[] == 2)
				return send("www.doc.view.pane", 
					    arg[0], arg[1]);
			else if (arg[] == 3)
				return send("www.doc.view.pane", 
					    arg[0], arg[1], arg[2]);
			else	return send("www.doc.view.pane", 
					    arg[0], arg[1], arg[2], arg[3]);
		}
		if (nthChar(arg[1], 0) == '#') {	
			pageYPos = send(pageObj, "gotoAnchor", 
					nthChar(arg[1], 1, 999));

			pageHeight = send(pageObj, "vspan");
			heightDiff = pageHeight - get("height");
			heightRatio =  float(heightDiff) / -100.0;

			if (heightDiff > 0) {
				sliderSize = float(get("height")) / 
						float(pageHeight) * 100;
				sliderPos = float(pageYPos) / 
						float(heightDiff) * 100;
				if (sliderPos > 100) sliderPos = 100;
			} else {
				sliderSize = 100;
				sliderPos = 0;
			}
			send(pageObj, "shownPositionV", sliderPos);
			objectListSend("shownDepend", "_shownInfoV", 
					sliderPos, sliderSize);
			objectListSend("shownDepend", "setShownNotify",
					pageObj);
		} else {
			if (arg[] == 2) 
				normURL = send("normalizeURL", "normalizeURL",
						arg[1]);
			else 
				normURL = send("normalizeURL", "normalizeURL",
						arg[1], arg[2]);

			oldDocName = docName;
			docName = normURL;
			docURL = normURL;

			if (findPattern(arg[1], "telnet:") != -1) {
				cmd = send("WWWTelnetHandler", "connect", 
						normURL);
				www.mesg.tf("warn", cmd);
				system(cmd);
				return normURL;
			} else if (findPattern(arg[1], "mailto:") != -1) {
				subject = concat("WWW mail from: ", 
						normURL);
				tt = arg[1];
				i = findPattern(tt, "/");
				if (i == -1) {
					address = nthChar(tt, 7, 999);
					content = concat(
				"This mail was generated by WWW URL:\n",
						   tt, "\n");
				} else {
					address = nthChar(tt, 7, i-1);
					content = concat(nthChar(tt, i+1, 999),
							 "\n");
				}
				tmpFile = makeTempFile();
				saveFile(tmpFile, content);

				cmd = concat("mail -s \"", subject,
					     "\" ", address, " < ", tmpFile);
				system(cmd);
				system(concat("rm ", tmpFile));
				return normURL;
			}
			anchor = parseHTTPAddress("anchor", normURL);

			if (exist(pageObj) == 1) send(pageObj, "undisplay");

			if (exist(docName) == 1) {
				set("children", docName);
				if (anchor != "")  {
					if (findPattern(docURL, ".hmml") > -1){
						pageYPos = send(docName, 
								"gotoAnchor",
								 anchor) * -1;
						send(docName, "y", pageYPos);
					}
				} else {
					pageYPos = send(docName, "yP");
				}
				if (send(docName, "configSideBar") == 1) {
					send(parent(), "linkSideBar", 
				  sideBarURL, sideBarRatio, sideBarMaxWidth);
				} else {
					send(parent(), "lbarConfig", "off");
				}
				send(docName, "display", width(), height());
			} else {
				/* a rough guess at the document type */
				handler = wwwFormatDetect("type", docURL);
				send("www.mesg.tf", "show", 
					    concat("Getting ", docURL));

				if (torn == 1) paneObj = "www.doc.view.pane";
				else paneObj = self();

				docObj = send("wwwHandlerDispatch", 
						"dispatch", handler,
						doPost, docURL,
						docName, paneObj,
						get("width"), get("height"),
						anchor, 1, postData);

				/* XXX kludgy stylesheet turn off */
				STG_clean(0);

				if (docObj == 0) {
					if (exist("www.mesg.tf"))
						www.mesg.tf("show",
						 concat("Failed ", docURL));
					winPos = windowPosition();
					res.dialogWithButtons("showAt", 
						winPos[0] + 20, winPos[1] + 20,
						500, 80,
						concat("Failed to access\n", 
							docURL),
						"Dismiss", "");
					return 0;
				} else if (docObj == 1) {
		/* It's OK.. no doc object generated but wasn't an error 
		 * (ie: to be rendered by external viewer) */
					return 0;
				}

				if (send(docName, "configSideBar") == 1) {
					send(parent(), "linkSideBar", 
				  sideBarURL, sideBarRatio, sideBarMaxWidth);
				} else {
					send(parent(), "lbarConfig", "off");
				}

				if (insertObjCount > 0) {
					for (i = 0; i < insertObjCount; i++)
						send(insertObj[i], "insert");
					insertObjCount = 0;
					send(self(), "R", 
						get("y"), get("width"));
				}
				send(docObj, "display", 
						get("width"), get("height"));
				send(docObj, "show");
				pageYPos = send(docObj, "yP");

			}
			oo = object(docName);
			if (oldDocName != docName) {
				if (pageObj) {
					send(pageObj, "VW_event", "VIEW_OFF");
				}
				pageObj = oo;
				send(pageObj, "VW_event", "VIEW_ON");
			} else {
				pageObj = oo;
			}

			pageHeight = send(pageObj, "vspan");
			send(self(), "configShare");
		}

		title = send(pageObj, "queryTitle");
		if (isBlank(title)) title = pageObj;
		www.doc.title.tf("show", title);

		/* Show original URL if viewing via Wayback Machine */
		addr = send(pageObj, "queryAddress");
		/* Rule: find "https://web.archive.org/web/", then drop until next '/' */
		prefix = "https://web.archive.org/web/";
		wbPos = findPattern(addr, prefix);

		if (wbPos != -1) {
			/* findPattern returns end index of match; move to char after prefix */
			wbAfter = wbPos + 1;
			wbRest = nthChar(addr, wbAfter, 999);
			wbSlash = findPattern(wbRest, "/");

			if (wbSlash != -1) {
				addr = nthChar(wbRest, wbSlash + 1, 999);
			}
		}
		www.url.tf("show", addr);

		if (notYetRecordedInitDocInHistory) {
			/* this special case for the initial document
			 */
			notYetRecordedInitDocInHistory = 0;
			send("www.doc.view.pane", "historyRecord");
		}

		return docName;
	break;
	case "toDoInsert":
		insertObj[insertObjCount] = arg[1];
		insertObjCount++;
		return;
	break;
	case "show_request_by_child":
	case "post_request_by_child":
		send("www", "busy");

		if (arg[0] == "post_request_by_child") realMesg = "post";
		else realMesg = "show";

		if (torn == 1) destObj = self();
		else destObj = object("www");

		if (arg[] == 3) stat = send(destObj, realMesg, arg[1], arg[2]);
		else stat = send(destObj, realMesg, arg[1], arg[2], arg[3]);

		if (stat) stat = send("www.doc.view.pane", "historyRecord");

		send("www", "idle");
		return stat;
	break;
	case "hintOn":
		www.mesg.tf("show", arg[1]);
		return;
	break;
	case "hintOff":
		www.mesg.tf("clear");
		return;
	break;
	case "setChildren":
		set("children", arg[1]);
		return;
	break;
	case "configShare":
		heightDiff = pageHeight - get("height");
		heightRatio =  float(heightDiff) / -100.0;
		if (heightDiff > 0) {
		  sliderSize = float(get("height")) / float(pageHeight) * 100;
		  sliderPos = float(pageYPos) / float(heightDiff) * -100;
		} else {
		  sliderSize = 100;
		  sliderPos = 0;
		}
		objectListSend("shownDepend", "_shownInfoV", 
				sliderPos, sliderSize);
		objectListSend("shownDepend", "setShownNotify", pageObj);
		return;
	break;
	case "configSliderGeom":
		pageHeight = send(pageObj, "vspan");
		send(self(), "configShare");
		return;
	break;
	case "configSlider":
		/* arg[1]	pageYPos
		 * arg[2]	pageHeight
		 */
		pageYPos = arg[1];
		pageHeight = arg[2];
		if (pageYPos + pageHeight < get("height")) {
			pageYPos = get("height") - pageHeight;
			if (pageYPos > 0) pageYPos = 0;
			send(pageObj, "y", pageYPos);
		}
		send(self(), "configShare");
		return;
	break;
	case "config":
		usual();
		if (send(pageObj, "viewP") == 1) {
			/* when switching from a sidebar'ed document to
			 * a non-sidebar document, this object will be
			 * 'configed' (and before the new document gets
			 * configed... so we don't want to bother 
			 * that document (pageObj) until it is ready
			 * (when viewP == 1).
			 */
			/* ask page object to do the calculation */
			send(pageObj, "resize", get("width"), get("height"));
			pageYPos = send(pageObj, "yP");
			pageHeight = send(pageObj, "vspan");
			if (pageYPos + pageHeight < get("height")) {
				pageYPos = get("height") - pageHeight;
				send(pageObj, "y", pageYPos);
			}
			send(self(), "configShare");
		}
		/* this call should not be necessary... what was it for? */
		/*objectListSend("shownDepend", "kludgeRender");*/

		configed = 1;
		return;
	break;
	case "update":
		pageObj = nthChild(0);
		pageHeight = arg[1];
		send(self(), "configShare");
		return;
	break;
	case "destroyDoc":
	case "destroyDoc_qualified":
		send(pageObj, "VW_event", "VIEW_OFF");
		send(pageObj, "visible", 0);
		send(pageObj, "freeSelf");
		pageObj = 0;
		return;
	break;
	case "addTool":
	case "removeTool":
	case "destroyTool":
		return send(parent(), arg[0], arg[1]);
	break;
	case "CE_change":
		/* arg[1] 	CE objPath
		 * arg[2]	CE newData
		 */
		return send(pageObj, arg[0], arg[1], arg[2]);
	break;
	case "CE_lock":  /* arg[1] 	CE objPath */
	case "CE_unlock":
	case "editMode":
	case "search":
		return send(pageObj, arg[0], arg[1]);
	break;
	case "searchByTag":
		/* arg[1]	english desc of searching field
		 * arg[2]	tag(set)
		 */
		send("res.getLineEntry", "show", 
			concat("Enter keyword to search in ", arg[1], '.'),
			"", self(), "searchByTag_specified");
		return;
	break;
	case "searchByTag_specified":
		/* arg[1]	tag
		 * arg[2]	keyword
		 */
		return send(pageObj, "searchByTag", arg[1], arg[2]);
	break;
	case "outputSGML":
		print("-------------\nTHIS FACILITY IS NOT YET WORKING\n");
		send(pageObj, "outputSGML");
		print("-------------\n");
		return;
	break;
	case "mailToAuthor":
		contactURL = send(pageObj, "queryAuthor");
		if (contactURL) {
			res.dialogWithButtons("show", 
			 concat("The declared author contact is:\n", 
				contactURL),
			 "Dismiss", "");
		} else {
			res.dialogWithButtons("show", 
			 "Sorry, no author contact declared in the document.",
			 "Dismiss", "");
		}
		return;
	break;
	case "linkSideBar":
		sideBarURL = arg[1];
		sideBarRatio = arg[2];
		sideBarMaxWidth = arg[3];
		return;
	break;
	case "showSrc":
	case "reload":
	case "clone":
		return send(nthChild(0), arg[0]);
	break;
	case "whichPageP":
		return nthChild(0);
	break;
	case "heightP":
		return height();
	break;
	case "expose":
/* Trap this event to inhibit the default behavior to re-arrange geometry
 * which would cause uncessary reloading of HTML docs (b/c children would
 * get config messages). We still want to use hpane here because we do want to
 * reload (to reformat) HTML docs if width is changed.
 */
		if (todo) {
			homeDoc = www("homeDocP");
			www("show", homeDoc);
			todo = 0;
		}
		return;
	break;
	case "historyRecord":
		send(pageObj, "historyRecord");
		return;
	break;
	case "R": /* happens sometimes. blah */
	case "reportNextID":
		return;
	break;
	case "getCurrentDocURL":
		return docURL;
	break;
	case "getCurrentDocTitle":
		return title;
	break;
	case "init":
		usual();
		notYetRecordedInitDocInHistory = 1;
		configed = 0;
		todo = 0;
		return;
	break;
	case "torn":
		/* arg[1]	orig object */
		torn = 1;
		send(nthChild(0), "torn", arg[1]);
		pageObj = nthChild(0);
		/* make self reset variables */
		send(self(), "update", send(pageObj, "vspan"));
		return;
	break;
	}
	usual();
