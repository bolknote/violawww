/*
 * viola_test_support.c
 *
 * Shared infrastructure for Viola interpreter tests.
 */
#include "viola_test_support.h"

/* Stub for symbols referenced by linked .o files but not needed in tests */
int verbose = 0;

/* External declarations for the interpreter pipeline */
extern AST *theAST;
extern int lineno;
extern char *yyscript;
extern int yyscriptidx;
extern char *yyobjcontext;
extern int yyscriptcontext;
extern int varArrayIdx;
extern int listRefArrayIdx;

extern int yyparse(void);
extern void set_parsing_string(char *s);
extern int init_scanutils(void);
extern int init_ast(void);
extern int init_ident(void);

/* Internal pcode buffer for compile_script() */
static union PCode test_pcode_buf[5000];

/* ========================================================================
 * Public API
 * ======================================================================== */

int viola_test_init(void)
{
    if (!init_ident()) { fprintf(stderr, "init_ident failed\n"); return 0; }
    if (!init_scanutils()) { fprintf(stderr, "init_scanutils failed\n"); return 0; }
    if (!init_ast()) { fprintf(stderr, "init_ast failed\n"); return 0; }
    return 1;
}

int try_parse(char *script)
{
    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    return (yyparse() == 0 && theAST != NULL);
}

AST *find_ast_type(AST *ast, int type)
{
    AST *found;
    for (; ast; ast = ast->next) {
        if (ast->type == type)
            return ast;
        if (ast->children) {
            found = find_ast_type(ast->children, type);
            if (found)
                return found;
        }
    }
    return NULL;
}

int compile_script(char *script)
{
    int pc_limit = 0;
    AST *ast;

    lineno = 1;
    yyscriptidx = 0;
    yyscript = script;
    yyobjcontext = "test";
    yyscriptcontext = SCRIPT_ORIGIN_TEMPORARY;
    set_parsing_string(yyscript);

    varArrayIdx = 0;
    listRefArrayIdx = 0;
    clearASTStack();

    if (yyparse() != 0 || theAST == NULL)
        return -1;

    if (!assignReferences(theAST, test_pcode_buf, &pc_limit))
        return -1;

    for (ast = theAST; ast; ast = ast->next)
        codeGen(ast, test_pcode_buf, &pc_limit);

    return pc_limit;
}

union PCode *viola_test_pcode(void)
{
    return test_pcode_buf;
}

/* ========================================================================
 * Mini pcode executor
 *
 * A minimal interpreter that handles the subset of opcodes generated by
 * simple scripts (integers, strings, variables, arithmetic, comparisons,
 * branches, NOT, UMINUS, increment/decrement). This avoids depending on
 * the full codeExec() which requires VObj, X11, the object system, etc.
 * ======================================================================== */

#define MINI_MAX_VARS 32
#define MINI_MAX_ITER 100000

static long mini_exec_internal(union PCode *pcode, int size, long *vars)
{
    int pc = 0;
    long reg = 0;
    int reg_is_str = 0;
    char *reg_s = NULL;
    int iter = 0;

    while (pc < size && iter++ < MINI_MAX_ITER) {
        long code = pcode[pc++].x;

        if (code & 0xe0000000) {
            /* Combined instruction: opcode in bits 16..27, data in bits 0..15 */
            int opcode = (int)((code >> 16) & 0x0fff);
            int data = (int)(code & 0x0000ffff);

            switch (opcode) {
            case CODE_INTEGER:
                reg = data;
                reg_is_str = 0;
                break;
            case CODE_CHAR:
                reg = data;
                reg_is_str = 0;
                break;
            case CODE_REF2:
                reg = (data < MINI_MAX_VARS) ? vars[data] : 0;
                reg_is_str = 0;
                break;
            case CODE_MOVTO_REF2:
                if (data < MINI_MAX_VARS) vars[data] = reg;
                break;
            case CODE_BR2:
                pc += data;
                break;
            case CODE_BR2_ZERO:
                if (reg == 0 && !reg_is_str) pc += data;
                break;
            case CODE_BR2_NZERO:
                if (reg != 0) pc += data;
                break;
            case CODE_NBR2:
                pc -= data;
                break;
            case CODE_NBR2_NZERO:
                if (reg != 0) pc -= data;
                break;
            case CODE_NBR2_ZERO:
                if (reg == 0) pc -= data;
                break;
            case CODE_LIST2:
            case CODE_LIST_REF2:
            case CODE_LISTC2:
            case CODE_GET2:
            case CODE_PUSH_SET2:
                break;
            case CODE_CALL2:
            case CODE_CALL2_C:
                pc++; /* skip function id */
                break;
            default:
                break;
            }
        } else {
            /* Regular (single-word opcode) instruction */
            switch ((int)code) {
            /* Setup */
            case CODE_PUSH_REFPS: {
                int n = (int)pcode[pc++].i;
                pc += n;
                break;
            }

            /* Unary */
            case CODE_NOT:
                if (reg_is_str)
                    reg = (!reg_s || !*reg_s) ? 1 : 0;
                else
                    reg = !reg;
                reg_is_str = 0;
                break;
            case CODE_UMINUS:
                reg = -reg;
                reg_is_str = 0;
                break;

            /* Literals */
            case CODE_INTEGER:
                reg = pcode[pc++].i;
                reg_is_str = 0;
                break;
            case CODE_FLOAT:
                pc++;
                break;
            case CODE_STRING:
                reg_s = pcode[pc++].s;
                reg_is_str = 1;
                break;
            case CODE_CHAR:
                reg = (long)pcode[pc++].c;
                reg_is_str = 0;
                break;

            /* Arithmetic with immediate int */
            case CODE_PLUS_INT:
                reg += pcode[pc++].i;
                break;
            case CODE_MINUS_INT:
                reg -= pcode[pc++].i;
                break;
            case CODE_MULT_INT:
                reg *= pcode[pc++].i;
                break;
            case CODE_DIV_INT: {
                long d = pcode[pc++].i;
                if (d) reg /= d;
                break;
            }
            case CODE_MOD_INT: {
                long d = pcode[pc++].i;
                if (d) reg %= d;
                break;
            }

            /* Comparison with immediate int */
            case CODE_EQ_INT:
                reg = (reg == pcode[pc++].i);
                break;
            case CODE_NE_INT:
                reg = (reg != pcode[pc++].i);
                break;
            case CODE_LT_INT:
                reg = (reg < pcode[pc++].i);
                break;
            case CODE_LE_INT:
                reg = (reg <= pcode[pc++].i);
                break;
            case CODE_GT_INT:
                reg = (reg > pcode[pc++].i);
                break;
            case CODE_GE_INT:
                reg = (reg >= pcode[pc++].i);
                break;
            case CODE_AND_INT:
                reg = reg && pcode[pc++].i;
                break;
            case CODE_OR_INT:
                reg = reg || pcode[pc++].i;
                break;

            /* Operations with immediate ref (variable) */
            case CODE_PLUS_REF: {
                int idx = (int)pcode[pc++].i;
                reg += (idx < MINI_MAX_VARS) ? vars[idx] : 0;
                break;
            }
            case CODE_MINUS_REF: {
                int idx = (int)pcode[pc++].i;
                reg -= (idx < MINI_MAX_VARS) ? vars[idx] : 0;
                break;
            }
            case CODE_LT_REF: {
                int idx = (int)pcode[pc++].i;
                reg = reg < ((idx < MINI_MAX_VARS) ? vars[idx] : 0);
                break;
            }
            case CODE_GT_REF: {
                int idx = (int)pcode[pc++].i;
                reg = reg > ((idx < MINI_MAX_VARS) ? vars[idx] : 0);
                break;
            }
            case CODE_EQ_REF: {
                int idx = (int)pcode[pc++].i;
                reg = (reg == ((idx < MINI_MAX_VARS) ? vars[idx] : 0));
                break;
            }
            case CODE_NE_REF: {
                int idx = (int)pcode[pc++].i;
                reg = (reg != ((idx < MINI_MAX_VARS) ? vars[idx] : 0));
                break;
            }
            case CODE_LE_REF: case CODE_GE_REF:
            case CODE_MULT_REF: case CODE_DIV_REF: case CODE_MOD_REF:
            case CODE_AND_REF: case CODE_OR_REF:
                pc++;
                break;

            /* Increment/decrement */
            case CODE_INC_PRE: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = ++vars[idx];
                break;
            }
            case CODE_INC_POST: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = vars[idx]++;
                break;
            }
            case CODE_DEC_PRE: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = --vars[idx];
                break;
            }
            case CODE_DEC_POST: {
                int idx = (int)pcode[pc++].i;
                if (idx < MINI_MAX_VARS) reg = vars[idx]--;
                break;
            }

            /* Assignment ops (consume operand) */
            case CODE_MOVTO_LIST:
            case CODE_PLUS_MOVTO_REF:  case CODE_MINUS_MOVTO_REF:
            case CODE_MOD_MOVTO_REF:   case CODE_MULT_MOVTO_REF:
            case CODE_DIV_MOVTO_REF:
            case CODE_PLUS_MOVTO_LIST: case CODE_MINUS_MOVTO_LIST:
            case CODE_MOD_MOVTO_LIST:  case CODE_MULT_MOVTO_LIST:
            case CODE_DIV_MOVTO_LIST:
                pc++;
                break;

            /* Immediate string/char/float binary ops */
            case CODE_PLUS_STR: case CODE_MINUS_STR: case CODE_MULT_STR:
            case CODE_DIV_STR:  case CODE_MOD_STR:   case CODE_EQ_STR:
            case CODE_NE_STR:   case CODE_LT_STR:    case CODE_LE_STR:
            case CODE_GT_STR:   case CODE_GE_STR:    case CODE_AND_STR:
            case CODE_OR_STR:
            case CODE_PLUS_CHAR: case CODE_MINUS_CHAR: case CODE_MULT_CHAR:
            case CODE_DIV_CHAR:  case CODE_MOD_CHAR:   case CODE_EQ_CHAR:
            case CODE_NE_CHAR:   case CODE_LT_CHAR:    case CODE_LE_CHAR:
            case CODE_GT_CHAR:   case CODE_GE_CHAR:    case CODE_AND_CHAR:
            case CODE_OR_CHAR:
            case CODE_PLUS_FLOAT: case CODE_MINUS_FLOAT: case CODE_MULT_FLOAT:
            case CODE_DIV_FLOAT:  case CODE_MOD_FLOAT:   case CODE_EQ_FLOAT:
            case CODE_NE_FLOAT:   case CODE_LT_FLOAT:    case CODE_LE_FLOAT:
            case CODE_GT_FLOAT:   case CODE_GE_FLOAT:    case CODE_AND_FLOAT:
            case CODE_OR_FLOAT:
                pc++;
                break;

            /* Stack-based binary ops (no extra data) */
            case CODE_EQ_STACK:
            case CODE_PLUS_POP: case CODE_MINUS_POP: case CODE_MULT_POP:
            case CODE_DIV_POP:  case CODE_MOD_POP:   case CODE_EQ_POP:
            case CODE_NE_POP:   case CODE_LT_POP:    case CODE_LE_POP:
            case CODE_GT_POP:   case CODE_GE_POP:    case CODE_AND_POP:
            case CODE_OR_POP:
                break;

            /* Misc */
            case CODE_PUSH:
            case CODE_POP:
            case CODE_CMP:
            case CODE_LOAD:
            case CODE_STMTS:
            case CODE_TOKENIZE_PUSH:
            case CODE_METH_SELF:
            case CODE_METH_PARENT:
                break;
            case CODE_METH_SEND:
                pc++;
                break;
            case CODE_RETURN:
                goto done;
            default:
                break;
            }
        }
    }
done:
    return reg;
}

long mini_exec_reg(union PCode *pcode, int size)
{
    long vars[MINI_MAX_VARS];
    memset(vars, 0, sizeof(vars));
    return mini_exec_internal(pcode, size, vars);
}

long mini_exec_var(union PCode *pcode, int size, int var_idx)
{
    long vars[MINI_MAX_VARS];
    memset(vars, 0, sizeof(vars));
    mini_exec_internal(pcode, size, vars);
    return (var_idx >= 0 && var_idx < MINI_MAX_VARS) ? vars[var_idx] : 0;
}
